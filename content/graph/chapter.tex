\chapter{Graph}

% \section{Fundamentals}
	% \kactlimport{BellmanFord.h}
	% \kactlimport{FloydWarshall.h}
	% \kactlimport{TopoSort.h}

\section{Network flow}
	% \kactlimport{PushRelabel.h}
	\kactlimport{MinCostMaxFlow.h}
	% \kactlimport{EdmondsKarp.h}
	\kactlimport{Dinic.h}
	\kactlimport{DinicWithScaling.h}
	\kactlimport{MinCut.h}
	\kactlimport{GlobalMinCut.h}
	\kactlimport{GomoryHu.h}

\section{Matching}
	% \kactlimport{hopcroftKarp.h}
	\kactlimport{DFSMatching.h}
	\kactlimport{MinimumVertexCover.h}
	\kactlimport{WeightedMatching.h}
	\kactlimport{GeneralMatching.h}

\section{DFS algorithms}
	\kactlimport{SCC.h}
	\kactlimport{BiconnectedComponents.h}
	\kactlimport{BlockCutTree.h}
	\kactlimport{2sat.h}
	\kactlimport{EulerWalk.h}
	\kactlimport{BipolarOrientation.h}

\section{Coloring}
	\kactlimport{EdgeColoring.h}

\section{Heuristics}
	\kactlimport{MaximalCliques.h}
	\kactlimport{MaximumClique.h}
	\kactlimport{MaximumIndependentSet.h}

\section{Trees}
	% \kactlimport{BinaryLifting.h}
	\kactlimport{LCA.h}
	\kactlimport{CompressTree.h}
	\kactlimport{HLD.h}
	\kactlimport{LinkCutTree.h}
	\kactlimport{DirectedMST.h}
	\kactlimport{Centroid.h}
	\kactlimport{JacobLinkCut.h}
	\subsection{Prufer Sequences}
		\textbf{Tree to seq:} Take lowest label leaf, print label of neighbour, until 2 nodes left\\
		\textbf{Seq to tree:} deg of each node = frequency in sequence+1. take lowest 1-degree node
		connect it to first value in sequence, increase sequence pointer. repeat.
